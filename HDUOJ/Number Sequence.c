//问题：栈溢出，递归太深！n可以取到100,000,000，递归基本上不行！！
/******************************************************************
#include<stdio.h>

int Add(int A,int B,int n)
{
	int p;
	if(n==1 || n==2)
		p=1;
	else
		p=(A*Add(A,B,n-1)+B*Add(A,B,n-2))%7;
	return p;
}
int main()
{
	int a,b,n;
	while(scanf("%d %d %d",&a,&b,&n)!=EOF && (a!=0 && b!=0 && n!=0))
	{
		printf("%d\n",Add(a,b,n));
	}
	return 0;
}
******************************************************************/
//问题：超时！！！
/*******************************************************************
#include<stdio.h>
int main()
{
	int s,s1,s2;
	int i,t;
	int a,b,n;
    while(scanf("%d %d %d",&a,&b,&n)!=EOF && (a!=0 && b!=0 && n!=0))
	{
		if(n==1 || n==2) s=1;
		for(i=3,s1=1,s2=1;i<=n;i++)
		{
           s=(a*s1+b*s2)%7;//求f[n]
		   t=s1;
		   s1=s;//记录f[n-1]
		   s2=t;//记录f[n-2]
		}
		printf("%d\n",s);
	}
	return 0;
}

 *********************************************************************/

#include<stdio.h>
int main()
{
	 int f[50];
	 int a,b,n,i;
	 f[1]=1;f[2]=1;//初始化
     while(scanf("%d %d %d",&a,&b,&n)!=EOF && (a!=0 && b!=0 && n!=0))
	{
		 for(i=3;i<51;i++)//f[i],f[i+1]各有七种取值，它们的排列组合就共有49种可能，至多到f[50],必然出现相同的排列组合
		 {//即f[1]=f[i],f[2]=f[i+1],i+1<=50,鸽巢原理
			 f[i]=(a*f[i-1]+b*f[i-2])%7;
			 if(f[i-1]==1 && f[i]==1) break;//找到了循环起点，就终止
		 }
		 i=i-2;//i越界，回到循环起点的前一位，即i记录的是循环周期
		 n=n%i;
		 if(n==0) n=i;//循环的最后一位
		 printf("%d\n",f[n]);
	 }
	return 0;
}
